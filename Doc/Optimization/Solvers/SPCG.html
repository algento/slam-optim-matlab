<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of SPCG</title>
  <meta name="keywords" content="SPCG">
  <meta name="description" content="Subgraph Preconditioned Conjugate Gradient">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
  <script type="text/javascript">
    if (top.frames.length == 0) { top.location = "../../index.html"; };
  </script>
</head>
<body>
<a name="_top"></a>
<!-- # Optimization --><!-- menu.html Solvers -->
<h1>SPCG
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>Subgraph Preconditioned Conjugate Gradient</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [x,info,res_v,error_v]=SPCG(A1,b1,A2,b2,maxIT,epsilon,startFromTree,plot_residual,mu) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Subgraph Preconditioned Conjugate Gradient</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 
0002 <a name="_sub0" href="#_subfunctions" class="code">function [x,info,res_v,error_v]=SPCG(A1,b1,A2,b2,maxIT,epsilon,startFromTree,plot_residual,mu)</a>
0003 <span class="comment">% Subgraph Preconditioned Conjugate Gradient</span>
0004 
0005 n= size(A1,2);
0006 <span class="keyword">if</span> (nargin &lt; 4)
0007     error(<span class="string">'Not enough input arguments.'</span>);
0008 <span class="keyword">end</span>
0009 
0010 <span class="keyword">if</span> (nargin &lt; 5)
0011     maxIT=n;
0012 <span class="keyword">end</span>
0013 
0014 <span class="keyword">if</span> (nargin &lt; 6)
0015     epsilon=0.01;
0016 <span class="keyword">end</span>
0017 
0018 <span class="keyword">if</span> (nargin &lt; 7)
0019     startFromTree=0;
0020 <span class="keyword">end</span>
0021 
0022 <span class="keyword">if</span> (nargin &lt; 8)
0023     plot_residual=0;
0024 <span class="keyword">end</span>
0025 
0026 <span class="keyword">if</span> (nargin &lt; 9)
0027     <span class="keyword">if</span> plot_residual
0028         error(<span class="string">'Error computation requires the mean'</span>);
0029     <span class="keyword">else</span>
0030         mu=0;
0031     <span class="keyword">end</span>
0032 <span class="keyword">end</span>
0033 
0034 
0035 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0036 <span class="comment">% solve the tree</span>
0037 ck=cputime;
0038 [c1,R1,p] = spqr (A1,b1, struct(<span class="string">'ordering'</span>,<span class="string">'fixed'</span>)) ;
0039 xbar= R1\c1; 
0040 R1=R1(1:n,1:n);
0041 timeSolveTree=(cputime-ck);
0042 
0043 
0044 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0045 <span class="comment">% initialization</span>
0046 it=1;
0047 b=[b1;b2];
0048 <span class="keyword">if</span> startFromTree
0049     <span class="comment">% if we want to start with y0 other than zero</span>
0050     ck=cputime;
0051     b2_bar=b2-A2*xbar;
0052     R1_t=R1';
0053     y=-R1*xbar;
0054     <span class="comment">%tmp= R1_t\A2';</span>
0055     <span class="comment">%g=y+tmp*(tmp'*y-b2_bar);</span>
0056     
0057     <span class="comment">%memory efficient</span>
0058     g= y + R1_t\((A2*(R1\y)-b2_bar)'*A2)';
0059     
0060     gamma=g'*g;
0061     d=-g;
0062     timeInit=(cputime-ck);
0063     threshold=epsilon^2*gamma *((norm(b)/norm(b2_bar))^2);<span class="comment">% set the threshold</span>
0064 <span class="keyword">else</span>
0065     ck=cputime;
0066     b2_bar=b2-A2*xbar;
0067     R1_t=R1';
0068     y=zeros(n,1);
0069     g=-(R1_t\(b2_bar'*A2)');
0070     gamma=g'*g;
0071     d=-g;
0072     timeInit=(cputime-ck);
0073     threshold=epsilon^2*gamma *((norm(b)/norm(b2_bar))^2);<span class="comment">% set the threshold</span>
0074 <span class="keyword">end</span>
0075 
0076 <span class="comment">% needed to compute residual and error</span>
0077 nb=norm(b);
0078 A=[A1;A2];
0079 <span class="keyword">if</span> plot_residual
0080     res_v=zeros(maxIT,1);
0081     error_v=zeros(maxIT,1);
0082     x=(R1\y+xbar);
0083     res_v(it)=norm(b-A*x)/nb;
0084     error_v(it)=(x-mu)'*(A'*(A*(x-mu)));
0085 <span class="keyword">end</span>
0086 
0087 
0088 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0089 <span class="comment">% iterations</span>
0090 done=false;
0091 
0092 timeIterations=0;
0093 <span class="keyword">while</span>  ~done
0094     ck=cputime;
0095     <span class="comment">%calculate step size and take optimal step</span>
0096     Ad=A2*(R1\d);
0097     <span class="comment">%alpha=-(d'*g)/(d'*d + Ad'*Ad); % can be simplified!!!</span>
0098     alpha=gamma/(d'*d + Ad'*Ad); 
0099     y=y+alpha*d;
0100     
0101     <span class="comment">%update gradient</span>
0102     g=g+alpha*(d+R1_t\(Ad'*A2)');
0103     new_gamma=g'*g;
0104     
0105     <span class="comment">%stop condition</span>
0106     done=((new_gamma&lt;threshold)||(it &gt;=maxIT));
0107     
0108     <span class="comment">%calculate new search direction</span>
0109     beta=new_gamma/gamma;
0110     d=-g+beta*d;
0111     
0112     <span class="comment">% prepare for next iteration</span>
0113     gamma=new_gamma;
0114     timeIterations=timeIterations+(cputime-ck);
0115     
0116     it=it+1;
0117     
0118     <span class="keyword">if</span> plot_residual
0119         x=(R1\y+xbar);
0120         res_v(it)=norm(b-A*x)/nb;
0121         error_v(it)=(x-mu)'*(A'*(A*(x-mu)));
0122     <span class="keyword">end</span>
0123 <span class="keyword">end</span>
0124 
0125 
0126 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0127 <span class="comment">%info solution + residual + error</span>
0128 <span class="comment">%These two are the same x=R1\(y+Q1'* b1) and x=R1\(y+R1*xbar);</span>
0129 
0130 <span class="keyword">if</span> plot_residual
0131     ck=cputime;
0132     timeSolution=(cputime-ck);
0133     res_v=res_v(1:it);
0134     info.res=res_v(it);
0135     error_v=error_v(1:it);
0136     info.error=error_v(it);
0137 <span class="keyword">else</span>
0138     ck=cputime;
0139     x=(R1\y+xbar);
0140     timeSolution=(cputime-ck);
0141     info.res=norm(b-A*x)/nb;
0142     <span class="comment">% if not plot_residual</span>
0143     res_v=[];
0144     error_v=[];
0145 <span class="keyword">end</span>
0146 
0147 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0148 <span class="comment">%%info time +it</span>
0149 info.timeSolveTree=timeSolveTree;
0150 info.timeInit=timeInit;
0151 info.timeIterations=timeIterations;
0152 info.timeSolution=timeSolution;
0153 <span class="comment">%info.time=timeSolveTree + timeInit + timeIterations + timeSolution;</span>
0154 info.time=timeSolveTree + timeIterations;
0155 info.it=it;
0156 
0157 <span class="comment">%tree solution</span>
0158 info.treeSolution=xbar; <span class="comment">% this is needed when comparing with GC</span>
0159 
0160 
0161 <span class="comment">% res=norm(b-A*x)/nb;</span>
0162 <span class="comment">% if plot_residual</span>
0163 <span class="comment">%     info.y_v=y_v(:,1:it);</span>
0164 <span class="comment">% end</span>
0165 <span class="comment">%</span>
0166 <span class="comment">% if plot_residual &amp;&amp; it</span>
0167 <span class="comment">%     info.x_v=R1\info.y_v+repmat(xbar,1,it);</span>
0168 <span class="comment">%</span>
0169 <span class="comment">%     info.res_v=sqrt(sum((repmat(b,1,it)-A*info.x_v).^2))/nb;</span>
0170 <span class="comment">% end</span></pre></div>
<hr><address>Generated on Wed 11-May-2011 19:51:36 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" target="_parent">m2html</a></strong> &copy; 2005</address>
</body>
</html>